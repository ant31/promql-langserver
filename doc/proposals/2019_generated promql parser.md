---
title: Replacing the PromQL Parser with a generated parser
type: Proposal
menu: proposals
status: WIP
owner: slrtbtfs
---
# Replacing the PromQL Parser with a generated parser

## Motivation

The upcoming PromQL language Server (see [proposal](https://github.com/sl>rtbtfs/promql-lsp/blob/master/doc/proposals/2019_promql-language-server.md)) it is necessary to analyze PromQL queries.

For this it is intended to use the same PromQL parser as prometheus. To enable that use case, changes to the parser have been [proposed](https://github.com/slrtbtfs/promql-lsp/blob/master/doc/proposals/2019_promql-parser-improvements.md). These mainly concern the _output_ of the parser and have already partly implemented.

This proposal is about replacing the _implementation_ of the parser. It has already been decided that the parser should be eventually replaced by a generated parser, which aligns with this proposal.

### Problems with the existing parser 

#### The Abstract Syntax Tree is too flat for syntax analysis

Consider the query:

    metric{label=="value", foo~="ba."}[5m] offset 3h

One would expect a the structure of the respective syntax tree approximately look like this:

    |---- OffsetModifier: metric{label=="value", foo~="ba."}[5m] offset 3h
    . . . |---- MatrixSelector: metric{label=="value", foo~="ba."}[5m]
    . . . . . . |---- VectorSelector: metric{label=="value", foo~="ba."}
    . . . . . . . . . |---- LabelMatcher: label=="value"
    . . . . . . . . . . . . |---- Label: label
    . . . . . . . . . . . . |---- Value: "value"
    . . . . . . . . . |---- LabelMatcher: foo~="ba."
    . . . . . . . . . . . . |---- Label: foo 
    . . . . . . . . . . . . |---- Value: "ba."

This is how it actually looks like with the current parser:

    |---- MatrixSelector: metric{label=="value", foo~="ba."}[5m] offset 3h

This is ok if all we want to do is evaluating PromQL queries. 

For using the data from the parser for things like autocompletion that works almost anywhere in the code, generating helpful error messages, showing function signatures and documentation while editing queries, etc., it isn't.


#### It is not really documented how a valid query looks like

While the documentation list examples of valid queries, but there are still undocumented features in the language (e.g. comments, see  #6198). Currently the only reliable way to figure out whether a query is valid is to check if the  parser accepts it.

#### The current parser does not return any results on incomplete expressions

For the features like completion it is necessary to still get results from the parser if the expression is not complete. The current parser does not have this feature.

## Technical Summary of the generated parser

It is proposed to replace the current PromQL parser with one that is generated by [goyacc](https://godoc.org/golang.org/x/tools/cmd/goyacc). 

The new parser is able to output two syntax tree formats:

* One that creates a deeper tree where almost every token is assigned a node which is to be used by the language server.

* A simplified tree that looks almost like the current one and that is to be used by the PromQL query engine.

The parser is able to parse incomplete expressions.

The changes proposed in a [previous proposal](https://github.com/slrtbtfs/promql-lsp/blob/master/doc/proposals/2019_promql-language-server.md) remain valid.

## Architecture

### lexer

Yacc relies on getting a stream of tokens from  a lexer. The new parser will keep using the logic of the existing lexer. The lexer output will be changed to satisfy the interfaces required by goyacc. To be consistent with the usual yacc conventions, token names will be capitalized.

### yacc grammar

The core part of the parser is a formal grammar of PromQL which is the input for the parser Generator.

The grammar is able to recognize all valid PromQL Queries as well as incomplete Queries.

As an example the part of the grammar recognizing an instant vector selector will look roughly like this:

    selector:
        IDENTIFIER                          {$$ = newVectorSelector(nil, $1}
      | IDENTIFIER LBRACE          RBRACE   {$$ = newVectorSelector(nil, $1, $2, nil, $3)}
      | IDENTIFIER LBRACE matchers RBRACE   {$$ = newVectorSelector(nil, $1, $2, $3,  $4)}
      | IDENTIFIER LBRACE matchers anything {$$ = newVectorSelector([]ErrCodes{
                                                                            ErrNoClosingBrace,
                                                                        }, $1, $2, $3,  $4)}

    matchers:
        matchers COMMA matcher              {$$ = newMatchers(nil, $1, $2, $3)}
      | matcher                             {$$ = newMatchers(nil, $1)}

    matcher:
        IDENTIFIER matchOp STRING           {$$ = newMatcher(nil, $1, $2, $3)}
      | IDENTIFIER matchOp anything         {$$ = newMatcher([]ErrCodes{
                                                                        ErrWrongType,
                                                                }, $1, $2, $3)}
      | IDENTIFIER anything                 {$$ = newMatcher([]ErrCodes{
                                                                        ErrNoMatchOp,
                                                                }, $1, $2, $3)}

    matchOp:
        EQ                                  {$$ = $1}
      | NEQ                                 {$$ = $1}
      | REGEQ                               {$$ = $1}
      | REGNEQ                              {$$ = $1}

    
    anything:
        // All valid PromQL Syntax Elements
        ...
        EOF
        error

### Building up the Abstract Syntax Tree (AST)

Every match in the grammar calls a function of the following type:

    func ([]ErrCodes, ...*Expr) *Expr

Tokens implement the Expr interface, so no special distinction has to be made here.

These functions gradually build up a syntax tree and perform all error and type checking on the way, using the hints provided by the passed `ErrCodes`

### The Expr interface

All Syntax tree nodes satisfy the `Expr` interface which will at least implement the following functions.

    type Expr interface {
        // A string representation
        String()     string
        // Position
        Pos()        token.Pos
        EndPos()     token.Pos
        // Errors in the respective subtree
        Errors()     []*ParseErr
        // The Type of the Expr
        Type()       ExprType
        // Simplifies the subtree to allow fast Evaluation by the PromQL engine
        Simplify()   *Expr
        // Reports if the subtree is already simplified. If yes, the subtree is 
        // skipped by Simplify() for performance reasons
        Simplified() bool
    }

### AST simplifying

The originally generated syntax tree provides a accurate and detailed representation of the query.

When evaluating queries in the PromQL engine, it is better to have a less complex syntax tree. For that reason the `Expr` interface has a function `Simplify()` that recurses through the subtree and tries to reduce the depth of the Tree. 

For example a Matrix Selector is simplified to the single Node format that is currently used and expected by the PromQL engine.

It is possible to implement additional optimizations like pre evaluation of scalar expressions.


## Scope of the change

The parser will obviously be completely rewritten.

The changes to the engine will be restricted to some refactoring due to interface and name changes in the AST.