---
title: PromQL Parser Improvements
type: Proposal
menu: proposals
status: WIP
owner: slrtbtfs
---

## PromQL Parser Improvements

### Abstract

For the planned PromQL language server (see Proposal 2019_promql-language-server) it is desirable to use the same parser as prometheus to ensure consistency and avoid code duplication.

The current Parser is not sufficient for that use case though.

The proposed changes include adding the necessary features to the parser, improving error handling and cleaning up the existing code Base.

### Technical summary

The proposed changes are intended to improve the metadata generated by the parser, to make it easier to analyze them.

All of the proposed concepts are already successfully employed by the go compiler itself.

### Proposed Changes

#### Implement consistent position handling within the PromQL Parser

##### Motivation

For the Purposes of a Language Server it is important to keep track of positions in Source Files and Querys. The PromQL Parser does not yet do that in a consistent way.

For example consider the following excerpts from the parser code.

For parser errors two values are used, one for line and one for column.

    // promql/parse.go:40
    // ParseErr wraps a parsing error with line and position context.
    // If the parsing input was a single line, line will be 0 and omitted
    // from the error string.
    type ParseErr struct {
        Line, Pos int
        Err       error
    }

Inside the lexer Positions are denoted by one integer, where the first char of the input string corresponds to 0.

    // promql/lex.go:315
    // Pos is the position in a string.
    type Pos int

The AST does not keep track of positions at all.

    // promql/ast.go:38
    type Node interface {
        // String representation of the node that returns the given node when parsed
        // as part of a valid query.
        String() s
    }

For comparison one might look at the go compiler, which uses the following two type to handle positions:

    // go/token/position.go:20
    type Position struct {
        Filename string // filename, if any
        Offset   int    // offset, starting at 0
        Line     int    // line number, starting at 1
        Column   int    // column number, starting at 1 (byte count)
    }

For efficient use inside the compiler it provides a more compact encoding. Conversions in both directions are possible.

     type Pos int

##### Proposed Change

It is proposed to use the aforementioned types from the `go/token` package.

It is _not proposed_ to actually import the whole `go/token` package, since most of it is specific to the golang compiler.
Instead just the definitions and procedures from position.go are used, with one change.

The case `Filename == NoFile && Line == 0` is considered valid. It denotes the case of a single line query that is not associated to a file.

The types from the previous section are changed to the following.

    type ParseErr struct {
        Pos       Pos
        Err       error
    }

    type Node interface {
        // String representation of the node that returns the given node when parsed
        // as part of a valid query. 
        // Kept for backwards compatibility
        String() s
        // Position of the Node 
        start() Pos
        // same as start() + len(s())
        end()   Pos
    }

The parser and lexer have to be updated accordingly.

By extending the `Node` Interface, code that only reads the AST, i.e. almost everything outside the parser, will still work.
Since the `ParseErr` struct still retains the error interface, this also shouldn't break to much Code outside the parser.

#### Handle Errors more consistent and gracefully.

TODO
